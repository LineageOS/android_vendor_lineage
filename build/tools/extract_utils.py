#!/usr/bin/env python
#
# Copyright (C) 2018 The LineageOS Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#

import argparse
import datetime
import hashlib
import operator
import os
import shutil
import sys


productmk = None
androidmk = None
boardmk = None
vendor_full_path = None

tmpdir = os.popen('mktemp -d').read().rstrip()


class Blob:
  source = None
  destination = None
  sha1sum = None
  blobtype = None
  extension = None
  presigned = False
  buildable = False

class Extractable:
  target = None
  source = None
  def __init__(self, target, source):
    self.target = target
    self.source = source

class Buildable:
  target = None
  sourcefile = None
  presigned = None
  def __init__(self, target, sourcefile, presigned):
    self.target = target
    self.sourcefile = sourcefile
    self.presigned = presigned


def getargs():
  # Gets command line arguments
  parser = argparse.ArgumentParser()
  parser.add_argument('-d', '--device', required=True)
  parser.add_argument('-v', '--vendor', required=True)
  parser.add_argument('-s', '--source', required=True)
  parser.add_argument('-r', '--root', required=True)
  parser.add_argument('-f', '--file', required=True)
  parser.add_argument('--copyright')
  parser.add_argument('--section')
  parser.add_argument('--no-cleanup', action='store_true', default=False)
  parser.add_argument('--common', action='store_true', default=False)
  parser.add_argument('--treble', action='store_true', default=False)
  parser.add_argument('--regen-only', action='store_true', default=False)
  parser.add_argument('--verbose', action='store_true', default=False)
  args, unknown = parser.parse_known_args()
  return args


def cleanup():
  shutil.rmtree(tmpdir)


def buildHeader(makefile):
  f = open(makefile, "w")

  current_year = datetime.datetime.now().year

  if current_year != args.copyright:
    f.write("# Copyright (C) " + args.copyright + "-" + str(current_year) + " The LineageOS Project\n")
  else:
    f.write("# Copyright (C) " + str(current_year) + " The LineageOS Project\n")

  f.write("#\n")
  f.write("# Licensed under the Apache License, Version 2.0 (the \"License\");\n")
  f.write("# you may not use this file except in compliance with the License.\n")
  f.write("# You may obtain a copy of the License at\n")
  f.write("#\n")
  f.write("# http://www.apache.org/licenses/LICENSE-2.0\n")
  f.write("#\n")
  f.write("# Unless required by applicable law or agreed to in writing, software\n")
  f.write("# distributed under the License is distributed on an \"AS IS\" BASIS,\n")
  f.write("# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n")
  f.write("# See the License for the specific language governing permissions and\n")
  f.write("# limitations under the License.\n")
  f.write("\n")
  f.write("# This file is generated by device/" + args.vendor + "/" + args.device + "/setup-makefiles.sh\n")
  f.write("\n")

  f.close()


def setup_vendor():
  global productmk
  global androidmk
  global boardmk
  global vendor_full_path

  vendor_dir = "vendor" + "/" + args.vendor + "/" + args.device
  vendor_full_path = os.path.join(args.root, vendor_dir)

  if not os.path.isdir(vendor_full_path):
    os.mkdir(vendor_full_path)

  productmk = os.path.join(vendor_full_path, args.device + "-vendor.mk")
  androidmk = os.path.join(vendor_full_path, "Android.mk")
  boardmk = os.path.join (vendor_full_path, "BoardConfigVendor.mk")

  buildHeader(boardmk)

  buildHeader(productmk)
  f = open(productmk, "a")
  f.write("PRODUCT_COPY_FILES +=")
  f.close()

  buildHeader(androidmk)
  f = open(androidmk, "a")
  f.write("LOCAL_PATH := $(call my-dir)\n")
  f.write("\n")
  f.write("ifeq ($(TARGET_DEVICE)," + args.device + ")\n")
  f.write("\n")
  f.close()


def breakLine(line):
  blob = Blob()

  s = line.split('|')
  if len(s) > 1:
    blob.sha1sum =  s[1]
    line = s[0]

  s = line.split(';')
  if len(s) > 1:
    if s[1] == "PRESIGNED":
      blob.presigned = True
    line = s[0]

  s = line.split(':')
  blob.source = s[0]
  if len(s) > 1:
    blob.destination = s[1]
  else:
    blob.destination = blob.source

  if blob.source[0] == "-":
    blob.buildable = True
    blob.source = blob.source[1:]
    blob.destination = blob.source

  blob.blobtype = os.path.dirname(blob.destination).split('/')[-1]
  blob.extension = blob.source.split('.')[-1]

  return blob


def getSha1sum(file):
  sha1sum = hashlib.sha1()
  with open(file, 'rb') as source:
    block = source.read(2**16)
    while len(block) != 0:
      sha1sum.update(block)
      block = source.read(2**16)

  return sha1sum.hexdigest()


def fixXml(file):
  tmp_xml = os.path.join(tmpdir, os.path.basename(file) + ".temp")

  os.popen("grep -a '^<?xml version' " + file + " > " + tmp_xml)
  os.popen("grep -av '^<?xml version' " + file + " >> " + tmp_xml)

  shutil.move(tmp_xml, file)


def extract():
  bloblist = []
  buildlist = []

  current_section = None
  with open(args.file, 'r') as f:
    for l in f:
      line = l.rstrip()

      if not line:
        continue

      if line[:2] == "# ":
        current_section = line[2:]
        continue

      if args.section and args.section.lower() != current_section.lower():
        continue

      if line[0] == "#":
        continue

      blob = breakLine(line)

      destination_dir = os.path.join(vendor_full_path + "/proprietary", os.path.dirname(blob.destination))
      if not os.path.exists(destination_dir):
        os.makedirs(destination_dir)

      destination_file = os.path.join(vendor_full_path + "/proprietary", blob.destination)
      if blob.sha1sum:
        if os.path.isfile(destination_file):
          old_sha1sum = getSha1sum(destination_file)
          if old_sha1sum == blob.sha1sum:
            if args.verbose:
              print("Keeping pinned blob for: " + blob.source)
            if not blob.buildable:
              bloblist.append(Extractable(target=blob.destination,
                                          source=blob.source))
            else:
              buildlist.append(Buildable(target=os.path.basename(blob.destination),
                                         sourcefile="proprietary/" + blob.destination,
                                         presigned=blob.presigned))
            continue
      else:
        if not args.regen_only and os.path.isfile(destination_file):
          os.remove(destination_file)

      full_source = os.path.join(args.source, blob.source)
      if not os.path.isfile(full_source):
        full_source = os.path.join(args.source + "/vendor", blob.source)
      if not os.path.isfile(full_source):
        full_source = os.path.join(args.source + "/system", blob.source)

      if not args.regen_only:
        shutil.copy(full_source, destination_dir)

        if blob.blobtype == "bin" or blob.blobtype == "sbin":
          os.chmod(destination_file, 0755)
        else:
          os.chmod(destination_file, 0644)

        if blob.extension == "xml":
          fixXml(destination_file)

      if not blob.buildable:
        bloblist.append(Extractable(target=blob.destination,
                                    source=blob.source))
      else:
        buildlist.append(Buildable(target=os.path.basename(blob.destination),
                                   sourcefile="proprietary/" + blob.destination,
                                   presigned=blob.presigned))

  if args.section:
    return

  mk = open(productmk, "a")
  amk = open(androidmk, "a")

  last_source = None
  for b in sorted(bloblist, key=operator.attrgetter('source')):
    if b.source == last_source:
      continue
    last_source = b.source

    if args.treble and b.target.split('/')[0] == "vendor":
      final_out = "$(TARGET_COPY_OUT_VENDOR)/" + b.target.replace("vendor/", "")
    else:
      final_out = "system/" + b.target

    mk.write(" \\\n    vendor/" + args.vendor + "/" + args.device + "/proprietary/" + b.target + ":" + final_out)

  mk.write("\n\n")
  mk.write("PRODUCT_PACKAGES +=")

  last_target = None
  for b in sorted(buildlist, key=operator.attrgetter('target')):
    if b.presigned:
      target_sig = "PRESIGNED"
    else:
      target_sig = "platform"

    target_base, target_suffix = os.path.splitext(b.target)

    if target_suffix == ".apk":
      target_class = "APPS"
    if target_suffix == ".xml":
      target_class = "ETC"
    elif target_suffix == ".so":
      target_class = "SHARED_LIBRARIES"

    if b.target == last_target:
      continue
    last_target = b.target

    multilib = None
    if target_class == "SHARED_LIBRARIES":
      if len([x for x in buildlist if x.target == b.target]) > 1:
        multilib = "both"
      elif "/lib64/" in b.sourcefile:
        multilib = "64"
      else:
        multilib = "32"

    privapp = False
    if target_class == "APPS" and "/priv-app/" in b.sourcefile:
      privapp = True

    amk.write("include $(CLEAR_VARS)\n")
    amk.write("LOCAL_MODULE := " + target_base + "\n")
    amk.write("LOCAL_MODULE_OWNER := " + args.vendor + "\n")
    if multilib == "both":
      amk.write("LOCAL_SRC_FILES_64 := " + b.sourcefile.replace("/lib/", "/lib64/") + "\n")
      amk.write("LOCAL_SRC_FILES_32 := " + b.sourcefile + "\n")
    else:
      amk.write("LOCAL_SRC_FILES := " + b.sourcefile + "\n")
    if target_class == "SHARED_LIBRARIES":
      amk.write("LOCAL_MULTILIB := " + multilib + "\n")
    if target_class == "APPS":
      amk.write("LOCAL_CERTIFICATE := " + target_sig + "\n")
    amk.write("LOCAL_MODULE_TAGS := optional\n")
    amk.write("LOCAL_MODULE_CLASS := " + target_class + "\n")
    if target_class == "APPS":
      amk.write("LOCAL_DEX_PREOPT := false\n");
    amk.write("LOCAL_MODULE_SUFFIX := " + target_suffix + "\n")
    if target_class == "APPS" and privapp:
      amk.write("LOCAL_PRIVILEGED_MODULE := true\n")
    else:
      amk.write("LOCAL_PROPRIETARY_MODULE := true\n")
    amk.write("include $(BUILD_PREBUILT)\n")
    amk.write("\n")

    mk.write(" \\\n    " + b.target)

  amk.write("\nendif\n")
  mk.write("\n")

  amk.close()
  mk.close()

args = getargs()

setup_vendor()
extract()

if not args.no_cleanup:
  cleanup()
